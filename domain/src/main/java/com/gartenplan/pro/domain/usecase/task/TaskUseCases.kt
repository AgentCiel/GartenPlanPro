package com.gartenplan.pro.domain.usecase.task

import com.gartenplan.pro.core.constants.TaskType
import com.gartenplan.pro.domain.model.Task
import com.gartenplan.pro.domain.repository.TaskRepository
import kotlinx.coroutines.flow.Flow
import java.time.LocalDate
import java.time.ZoneId
import java.util.UUID
import javax.inject.Inject

/**
 * Get all tasks for a garden
 */
class GetTasksByGardenUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String): Flow<List<Task>> = 
        repository.getTasksByGarden(gardenId)
}

/**
 * Get tasks for a specific date
 */
class GetTasksForDateUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String, date: LocalDate): Flow<List<Task>> {
        val dayStart = date.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        val dayEnd = date.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        return repository.getTasksForDay(gardenId, dayStart, dayEnd)
    }
}

/**
 * Get tasks for a date range (e.g., current month)
 */
class GetTasksForDateRangeUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String, startDate: LocalDate, endDate: LocalDate): Flow<List<Task>> {
        val start = startDate.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        val end = endDate.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        return repository.getTasksForDateRange(gardenId, start, end)
    }
}

/**
 * Get pending tasks (due today or earlier, not completed)
 */
class GetPendingTasksUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String): Flow<List<Task>> {
        val today = LocalDate.now().plusDays(1)
            .atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        return repository.getPendingTasks(gardenId, today)
    }
}

/**
 * Get overdue tasks
 */
class GetOverdueTasksUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String): Flow<List<Task>> {
        val today = LocalDate.now()
            .atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        return repository.getOverdueTasks(gardenId, today)
    }
}

/**
 * Get upcoming tasks (next X days)
 */
class GetUpcomingTasksUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String, days: Int = 7): Flow<List<Task>> {
        val today = LocalDate.now()
            .atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        val endDate = LocalDate.now().plusDays(days.toLong())
            .atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        return repository.getUpcomingTasks(gardenId, today, endDate)
    }
}

/**
 * Count pending tasks
 */
class CountPendingTasksUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String): Flow<Int> = 
        repository.countPendingTasks(gardenId)
}

/**
 * Count tasks for today
 */
class CountTodayTasksUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    operator fun invoke(gardenId: String): Flow<Int> {
        val today = LocalDate.now()
        val dayStart = today.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        val dayEnd = today.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        return repository.countTasksForToday(gardenId, dayStart, dayEnd)
    }
}

/**
 * Create a new task
 */
class CreateTaskUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(
        gardenId: String,
        title: String,
        taskType: TaskType,
        dueDate: LocalDate,
        description: String? = null,
        bedId: String? = null,
        plantId: String? = null,
        priority: Int = 2,
        reminderTime: Long? = null
    ): String {
        val task = Task(
            id = UUID.randomUUID().toString(),
            gardenId = gardenId,
            bedId = bedId,
            plantId = plantId,
            title = title,
            description = description,
            taskType = taskType,
            dueDate = dueDate.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli(),
            reminderTime = reminderTime,
            priority = priority,
            isAutoGenerated = false
        )
        return repository.createTask(task)
    }
}

/**
 * Update a task
 */
class UpdateTaskUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(task: Task) {
        repository.updateTask(task)
    }
}

/**
 * Delete a task
 */
class DeleteTaskUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(taskId: String) {
        repository.deleteTask(taskId)
    }
}

/**
 * Mark task as completed
 */
class CompleteTaskUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(taskId: String) {
        repository.markTaskCompleted(taskId)
    }
}

/**
 * Mark task as not completed (undo)
 */
class UncompleteTaskUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(taskId: String) {
        repository.markTaskNotCompleted(taskId)
    }
}

/**
 * Toggle task completion status
 */
class ToggleTaskCompletionUseCase @Inject constructor(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(taskId: String) {
        val task = repository.getTaskById(taskId) ?: return
        if (task.isCompleted) {
            repository.markTaskNotCompleted(taskId)
        } else {
            repository.markTaskCompleted(taskId)
        }
    }
}
